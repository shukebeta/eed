#!/bin/bash
# Enhanced ed wrapper with Modify-Preview-Confirm workflow
# Usage: eed [--debug] [--force] [--disable-auto-reorder] <file> <ed_commands...>
#
# Options:
#   --debug    Enable debug mode (preserve temp files, show ed output)
#   --force    Skip preview-confirm workflow, edit file directly
#   --disable-auto-reorder  Disable automatic script reordering
#
# Examples:
#   eed file.txt "5d"                           # Delete line 5 (with preview)
#   eed --force file.txt "5d"                   # Delete line 5 (direct edit)
#   eed file.txt "3c" "new content" "."         # Replace line 3
#   eed file.txt "5a" "new line" "."            # Insert after line 5
#   eed file.txt "1,3d"                         # Delete lines 1-3
#   eed file.txt "s/old/new/g"                  # Replace all 'old' with 'new' on current line
#   eed file.txt "1,\$s/old/new/g"              # Replace all 'old' with 'new' in entire file

# Disable history expansion to prevent ! character escaping
set +H

# Load library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/eed_common.sh"
source "$SCRIPT_DIR/lib/eed_validator.sh"

# --- Argument Parsing & Mode Handling ---
DEBUG_MODE=false
FORCE_MODE=false
DISABLE_AUTO_REORDER=false
FORGOT_STDIN_ARG_FLAG=false

# Parse flags with proper argument handling
while [ $# -gt 0 ]; do
    case "$1" in
        --debug)
            DEBUG_MODE=true
            shift
            ;;
        --force)
            FORCE_MODE=true
            shift
            ;;
        --disable-auto-reorder)
            DISABLE_AUTO_REORDER=true
            shift
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            exit 1
            ;;
        *)
            # Break the loop once we hit non-flag arguments
            break
            ;;
    esac
done

# Enforce single parameter mode after parsing flags
# Determine final FILE and ED_SCRIPT in a clear, ordered way:
# 1) forgiving stdin mode: only FILE provided and stdin has data
# 2) explicit two-argument mode: FILE and SCRIPT (or '-')
# 3) otherwise: show usage and exit
if [ $# -eq 1 ] && ! [ -t 0 ]; then
    # Forgiving stdin mode: user likely piped instructions but forgot '-'
    FORGOT_STDIN_ARG_FLAG=true
    FILE="$1"
    ED_SCRIPT=$(cat)
    if [ -z "$ED_SCRIPT" ]; then
        echo "Error: Empty script read from stdin" >&2
        exit 1
    fi
elif [ $# -eq 2 ]; then
    # Standard two-argument mode
    FILE="$1"
    ED_SCRIPT="$2"
else
    # Invalid usage
    show_usage
    exit 1
fi



# Handle stdin script input
if [ "$ED_SCRIPT" = "-" ]; then
    echo "Note: Reading ed script from standard input..." >&2
    if [ -t 0 ]; then
        echo "Error: No input provided to stdin" >&2
        exit 1
    fi
    ED_SCRIPT=$(cat)
    if [ -z "$ED_SCRIPT" ]; then
        echo "Error: Empty script read from stdin" >&2
        exit 1
    fi
fi


# --- Pre-processor Validation ---
validation_result=$(validate_ed_script "$ED_SCRIPT")
validation_code=$?
echo "$validation_result" >&2

if [ $validation_code -ne 0 ]; then
    exit 1
fi

# Handle empty script case
if [ -z "$ED_SCRIPT" ] || [ "$ED_SCRIPT" = "" ]; then
    echo "âœ“ No operations performed (empty script)"
    exit 0
fi

# --- Dot Trap Detection and Guidance ---
if ! detect_dot_trap "$ED_SCRIPT" >/dev/null; then
    # Potential dot trap detected, provide guidance
    suggest_dot_fix "$ED_SCRIPT"
fi

# --- Log Commands for Analysis ---
log_ed_commands "$ED_SCRIPT"

# --- Automatic Script Reordering for Line Number Safety ---
# Get potentially reordered script to prevent line numbering conflicts
if [ "$DISABLE_AUTO_REORDER" = "false" ]; then
    REORDERED_SCRIPT=$(reorder_script_if_needed "$ED_SCRIPT")
    if [ $? -eq 1 ]; then
        # Reordering was performed, use the reordered script
        ED_SCRIPT="$REORDERED_SCRIPT"
    fi
fi

# Check if file exists, create if needed
if [ ! -f "$FILE" ]; then
    echo "Creating new file: $FILE"
    echo > "$FILE"  # Create file with one empty line instead of zero bytes
fi

# --- Core Execution Logic with Preview-Confirm ---

# 1. Classify script to determine workflow
SCRIPT_TYPE=$(classify_ed_script "$ED_SCRIPT")

# 2. Handle invalid commands before executing ed
if [ "$SCRIPT_TYPE" = "invalid_command" ]; then
    echo "âœ— Error: Invalid ed command detected" >&2
    echo "Script contains unrecognized commands:" >&2
    echo "$ED_SCRIPT" >&2
    exit 1
fi

# 3. Handle view-only scripts (no changes, simple execution)
if [ "$SCRIPT_TYPE" = "view_only" ]; then
    # Create secure temporary command file
    TEMP_CMD_FILE=$(mktemp)
    cleanup() {
        if [ "$DEBUG_MODE" = false ]; then
            rm -f "$TEMP_CMD_FILE"
        else
            echo "Debug mode: temporary file preserved at $TEMP_CMD_FILE" >&2
        fi
    }
    trap cleanup EXIT

    # Write the complete ed script to temp file
    printf '%s\n' "$ED_SCRIPT" >> "$TEMP_CMD_FILE"

    # Execute ed with error handling
    if [ "$DEBUG_MODE" = true ]; then
        echo "Debug mode: executing ed with commands from $TEMP_CMD_FILE" >&2
        echo "Debug mode: ed command file contents:" >&2
        cat -n "$TEMP_CMD_FILE" >&2
        echo "Debug mode: ed output:" >&2
        ed -s "$FILE" < "$TEMP_CMD_FILE"
        ED_EXIT_CODE=$?
    else
        ed -s "$FILE" < "$TEMP_CMD_FILE"
        ED_EXIT_CODE=$?
    fi

    # Handle ed result for view operations
    case $ED_EXIT_CODE in
        0)
            echo "âœ“ Successfully processed $FILE"
            if [ "$FORGOT_STDIN_ARG_FLAG" = true ]; then
                echo "ðŸ’¡ Tip: '-' was missing; I read from stdin this time."
            fi
            ;;
        1)
            echo "âœ“ View operation completed (no matches found)"
            if [ "$FORGOT_STDIN_ARG_FLAG" = true ]; then
                echo "ðŸ’¡ Tip: '-' was missing; I read from stdin this time."
            fi
            exit 0
            ;;
        2)
            echo "âœ— File I/O error" >&2
            exit 2
            ;;
        3)
            echo "âœ— Internal ed error" >&2
            exit 3
            ;;
    esac
    exit $ED_EXIT_CODE
fi

# 4. Handle modifying scripts with the new preview-confirm workflow
if [ "$SCRIPT_TYPE" = "has_modifying" ]; then
    TARGET_FILE="$FILE"
    PREVIEW_FILE="$FILE.eed.preview"

    # Decide on editing mode
    if [ "$FORCE_MODE" = true ]; then
        echo "Note: --force mode enabled. Editing preview file, will apply directly." >&2
        cp "$TARGET_FILE" "$PREVIEW_FILE"
        ED_TARGET="$PREVIEW_FILE"  # Always edit preview file
        BACKUP_CREATED=true
    else
        # DEFAULT BEHAVIOR: Work on a copy, leave original untouched
        cp "$TARGET_FILE" "$PREVIEW_FILE"
        ED_TARGET="$PREVIEW_FILE" # ed will edit the preview file\!
        BACKUP_CREATED=false  # In preview mode, preview is the working copy
    fi

    # Create and prepare the temp command file
    TEMP_CMD_FILE=$(mktemp)
    cleanup() {
        if [ "$DEBUG_MODE" = false ]; then
            rm -f "$TEMP_CMD_FILE"
        else
            echo "Debug mode: temporary file preserved at $TEMP_CMD_FILE" >&2
        fi
    }
    trap cleanup EXIT

    printf '%s\n' "$ED_SCRIPT" > "$TEMP_CMD_FILE"

    # Execute ed on the chosen target (original or preview)
    if [ "$DEBUG_MODE" = true ]; then
        echo "Debug mode: executing ed with commands from $TEMP_CMD_FILE" >&2
        echo "Debug mode: ed command file contents:" >&2
        cat -n "$TEMP_CMD_FILE" >&2
        echo "Debug mode: ed output:" >&2
        ed -s "$ED_TARGET" < "$TEMP_CMD_FILE"
        ED_EXIT_CODE=$?
    else
        ed -s "$ED_TARGET" < "$TEMP_CMD_FILE"
        ED_EXIT_CODE=$?
    fi

    # Handle ed's result
    if [ $ED_EXIT_CODE -ne 0 ]; then
        case $ED_EXIT_CODE in
            1)
                if [ "$FORCE_MODE" = true ]; then
                    echo "âœ— Edit command failed, restoring preview" >&2
                    if [ "$BACKUP_CREATED" = true ]; then
                        mv "$PREVIEW_FILE" "$FILE"
                    fi
                else
                    echo "âœ— Edit command failed" >&2
                    echo "  No changes were made to the original file." >&2
                    rm -f "$PREVIEW_FILE"
                fi
                ;;
            2)
                echo "âœ— File I/O error" >&2
                if [ "$FORCE_MODE" = true ] && [ "$BACKUP_CREATED" = true ]; then
                    mv "$PREVIEW_FILE" "$FILE"
                else
                    rm -f "$PREVIEW_FILE"
                fi
                ;;
            3)
                echo "âœ— Internal ed error" >&2
                if [ "$FORCE_MODE" = true ] && [ "$BACKUP_CREATED" = true ]; then
                    mv "$PREVIEW_FILE" "$FILE"
                else
                    rm -f "$PREVIEW_FILE"
                fi
                ;;
        esac
        echo "Commands attempted:" >&2
        cat "$TEMP_CMD_FILE" >&2
        exit $ED_EXIT_CODE
    fi

    # --- Success Path ---
    if [ "$FORCE_MODE" = true ]; then
        echo "âœ“ Successfully edited preview file."
        echo "ðŸ’¡ Applying changes: mv '$PREVIEW_FILE' '$FILE'"
        mv "$PREVIEW_FILE" "$FILE"
        # Friendly post-success tip if we auto-read stdin
        if [ "$FORGOT_STDIN_ARG_FLAG" = true ]; then
            echo "ðŸ’¡ Tip: '-' was missing; I read from stdin this time."
        fi
        # Check if inside a Git repository before giving the tip
        if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
            echo "ðŸ’¡ Next, stage your changes: git add '$FILE'"
        fi
    else
        # The "Preview and Confirm" magic happens here
        echo "âœ“ Edits applied to a temporary preview. Review the changes below:"
        echo ""
        # Generate and print intelligent diff
        if command -v git >/dev/null 2>&1; then
            git diff --no-index --color=auto "$FILE" "$PREVIEW_FILE" || true
        elif command -v delta >/dev/null 2>&1; then
            delta "$FILE" "$PREVIEW_FILE" || true
        else
            diff -u --color=auto "$FILE" "$PREVIEW_FILE" || true
        fi

        echo ""
        echo "To apply these changes, run:"
        echo "  mv '$PREVIEW_FILE' '$FILE'"
        echo ""
        echo "To discard these changes, run:"
        echo "  rm '$PREVIEW_FILE'"
        if [ "$FORGOT_STDIN_ARG_FLAG" = true ]; then
            echo ""
            echo "ðŸ’¡ Tip: '-' was missing; I read from stdin this time."
        fi
    fi
fi
