#!/bin/bash

# eed - AI-oriented text editor with preview-confirm workflow
# Provides bulletproof safety guarantees and intelligent automation for AI systems

set -euo pipefail

# --- Configuration ---
REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$REPO_ROOT/lib/eed_validator.sh"

# Global settings
DEBUG_MODE="${EED_DEBUG:-false}"
DISABLE_AUTO_REORDER="${EED_DISABLE_AUTO_REORDER:-false}"
FORCE_OVERRIDE="${EED_FORCE_OVERRIDE:-false}"

# Testing mode (prevents log file creation)
TESTING_MODE="${EED_TESTING:-false}"

# --- Help and Usage ---
show_help() {
    cat << 'EOF'
Usage: eed [OPTIONS] <file> [ed_script | -]

AI-oriented text editor with bulletproof safety guarantees

OPTIONS:
  --force         Apply changes directly (skip preview mode)
  --debug         Show detailed debugging information
  --disable-auto-reorder  Disable automatic command reordering
  --help          Show this help message

ARGUMENTS:
  file            Target file to edit (will be created if it doesn't exist)
  ed_script       Ed commands as string, or '-' to read from stdin
  -               Read ed script from stdin (alternative to ed_script)

EXAMPLES:
  # Preview mode (default - safe)
  eed file.txt "1a\nHello\n.\nw\nq"

  # Direct mode (skip preview)
  eed --force file.txt "1d\nw\nq"

  # Read from stdin
  echo "1a\nContent\n.\nw\nq" | eed file.txt -

WORKFLOW:
  1. Validates ed commands for safety
  2. Creates preview in file.eed.preview
  3. Shows diff and instructions (unless --force)
  4. Provides clear next steps

SAFETY FEATURES:
  - Original files never corrupted
  - Preview-first workflow
  - Automatic command reordering
  - Line number validation
  - Git integration
EOF
}

# --- Argument Parsing ---
FORCE_MODE=false
FILE_PATH=""
ED_SCRIPT=""
ED_SCRIPT_PROVIDED=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --force)
            FORCE_MODE=true
            shift
            ;;
        --debug)
            DEBUG_MODE=true
            shift
            ;;
        --disable-auto-reorder)
            DISABLE_AUTO_REORDER=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        -)
            # Handle stdin marker as regular argument (Unix standard)
            if [ -z "$FILE_PATH" ]; then
                FILE_PATH="$1"
            elif [ "$ED_SCRIPT_PROVIDED" = false ]; then
                ED_SCRIPT="$1"
                ED_SCRIPT_PROVIDED=true
            else
                echo "✗ Error: Too many arguments" >&2
                echo "Use 'eed --help' for usage information" >&2
                exit 1
            fi
            shift
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            echo "Use 'eed --help' for usage information" >&2
            exit 1
            ;;
        *)
            if [ -z "$FILE_PATH" ]; then
                FILE_PATH="$1"
            elif [ "$ED_SCRIPT_PROVIDED" = false ]; then
                ED_SCRIPT="$1"
                ED_SCRIPT_PROVIDED=true
            else
                echo "✗ Error: Too many arguments" >&2
                echo "Use 'eed --help' for usage information" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required arguments
if [ -z "$FILE_PATH" ]; then
    echo "✗ Error: File path is required" >&2
    echo "Use 'eed --help' for usage information" >&2
    exit 1
fi

# Handle empty script case first (only for explicitly provided empty string)
if [ "$ED_SCRIPT_PROVIDED" = true ] && [ "$ED_SCRIPT" = "" ]; then
    echo "✗ Error: Empty ed script provided" >&2
    echo "Please provide valid ed commands to execute" >&2
    exit 1
fi

# Handle stdin input (for missing ED_SCRIPT or explicit '-')
if [ "$ED_SCRIPT" = "-" ] || [ "$ED_SCRIPT_PROVIDED" = false ]; then
    if [ -t 0 ]; then
        echo "✗ Error: Ed script is required (provide as argument or via stdin)" >&2
        echo "Use 'eed --help' for usage information" >&2
        exit 1
    fi
    ED_SCRIPT=$(cat)
fi

# Print debug info early if enabled
if [ "$DEBUG_MODE" = true ]; then
    echo "Debug mode: executing ed" >&2
fi
if [ "$FORCE_MODE" = true ] && [ "$DEBUG_MODE" = true ]; then
    echo "--force mode enabled" >&2
fi


# --- Script Validation ---
validation_result=$(validate_ed_script "$ED_SCRIPT")
validation_code=$?
echo "$validation_result" >&2

if [ $validation_code -ne 0 ]; then
    exit 1
fi


# --- Auto-fix unterminated input blocks (a/c/i)
if ! FIXED_SCRIPT=$(detect_and_fix_unterminated_input "$ED_SCRIPT"); then
    exit 1
fi
ED_SCRIPT="$FIXED_SCRIPT"

# --- Dot Trap Detection and Smart Handling ---
if ! detect_dot_trap "$ED_SCRIPT" >/dev/null; then
    # Try smart dot protection first for appropriate contexts
    SMART_HANDLED_SCRIPT=$(apply_smart_dot_handling "$ED_SCRIPT" "$FILE_PATH")
    smart_handling_result=$?

    if [ $smart_handling_result -eq 0 ]; then
        # Smart protection was applied successfully
        ED_SCRIPT="$SMART_HANDLED_SCRIPT"
    else
        # Smart protection not applied, fall back to standard guidance
        suggest_dot_fix "$ED_SCRIPT"
    fi
fi

# --- Log Commands for Analysis ---
# --- EARLY COMMAND VALIDATION ---

SCRIPT_TYPE=$(classify_ed_script "$ED_SCRIPT")

# Handle invalid commands immediately (before any complex analysis)
if [ "$SCRIPT_TYPE" = "invalid_command" ]; then
    echo "✗ Error: Invalid ed command detected" >&2
    echo "Please check your ed script syntax" >&2
    exit 1
fi

# --- File Creation (after script validation) ---
if [ ! -f "$FILE_PATH" ]; then
    # Create file and any necessary parent directories
    mkdir -p "$(dirname "$FILE_PATH")"
    # First create then show message (test expects exact message)
    # Create file with single empty line to avoid ed line number issues
    echo "" > "$FILE_PATH"
    echo "Creating new file: $FILE_PATH" >&2
fi

# --- Line Number Validation ---
if ! validate_line_ranges "$ED_SCRIPT" "$FILE_PATH"; then
    echo "✗ Error: Line number validation failed" >&2
    echo "Please check that line numbers exist in the file" >&2
    exit 1
fi

# Determine effective force mode (may be cancelled by safety measures)
effective_force_mode="$FORCE_MODE"

# --- Complex Pattern Analysis for Safety Override ---
HAS_COMPLEX_PATTERNS=0
# Override for testing/emergency use
if [ "$FORCE_OVERRIDE" = 1 ]; then
    effective_force_mode=true
    echo "⚠️  FORCE_OVERRIDE enabled - bypassing all safety checks" >&2
else
    if ! detect_complex_patterns "$ED_SCRIPT" >/dev/null 2>&1; then
        HAS_COMPLEX_PATTERNS=1
    fi
fi

# If complex patterns are detected, disable force mode to avoid destructive changes.
# Emit a single, clear user-facing message so CI and users can detect this condition.
# Do not disable if FORCE_OVERRIDE is explicitly set.
if [ "$HAS_COMPLEX_PATTERNS" -ne 0 ] && [ "$effective_force_mode" = true ] && [ "$FORCE_OVERRIDE" != true ]; then
    effective_force_mode=false
    echo "💡 Complex script detected (--force disabled)" >&2
fi

# --- Automatic Script Reordering for Line Number Safety ---
# Skip reordering if complex patterns detected (unified architecture)
if [ "$DISABLE_AUTO_REORDER" = "false" ] && [ $HAS_COMPLEX_PATTERNS -eq 0 ]; then
    # Run reordering and capture its output
    REORDERED_OUTPUT=""
    REORDERED_OUTPUT_AND_STATUS=$(reorder_script "$ED_SCRIPT"; echo $?)
    # Extract last line as return value, rest as output
    reorder_result=$(echo "$REORDERED_OUTPUT_AND_STATUS" | tail -n1)
    REORDERED_OUTPUT=$(echo "$REORDERED_OUTPUT_AND_STATUS" | head -n -1)
    if [ "$reorder_result" -eq 1 ]; then
        # Reordering occurred, use the reordered script
        ED_SCRIPT="$REORDERED_OUTPUT"
        [ "$DEBUG_MODE" = true ] && echo "Debug mode: using reordered script:" >&2
        [ "$DEBUG_MODE" = true ] && echo "$ED_SCRIPT" | sed 's/^/  /' >&2

        # Cancel --force when reordering occurs
        if [ "$effective_force_mode" = true ]; then
            echo "💡 Script reordered for safety (--force disabled)" >&2
            effective_force_mode=false
        fi
    else
        # No reordering, use original script
        ED_SCRIPT="$REORDERED_OUTPUT"
    fi
    # Always succeed after reordering (treat as normal operation)
    true
elif [ $HAS_COMPLEX_PATTERNS -ne 0 ]; then
    # Complex patterns detected in non-force mode, skip reordering
    if [ "$DEBUG_MODE" = true ]; then
        echo "ℹ️  Skipping auto-reorder due to complex patterns" >&2
    fi
fi

# --- Ed Execution and Preview Generation ---

# For view-only commands, execute directly without preview
if [ "$SCRIPT_TYPE" = "view_only" ]; then
    if [ "$DEBUG_MODE" = true ]; then
        echo "Debug mode: executing view-only command" >&2
    fi
    printf '%s\n' "$ED_SCRIPT" | ed -s "$FILE_PATH" 2>/dev/null || true
    exit 0
fi

# For modifying commands, use preview workflow
PREVIEW_FILE="${FILE_PATH}.eed.preview"

# Copy file and execute ed
cp "$FILE_PATH" "$PREVIEW_FILE"

if [ "$DEBUG_MODE" = true ]; then
    echo "Debug mode: executing ed" >&2
    [ "$effective_force_mode" = true ] && echo "--force mode enabled" >&2
fi

if ! printf '%s\n' "$ED_SCRIPT" | ed -s "$PREVIEW_FILE" 2>/dev/null; then
    echo "✗ Edit command failed" >&2
    echo "  No changes were made to the original file." >&2
    echo "Commands attempted:" >&2
    echo "$ED_SCRIPT" >&2
    rm -f "$PREVIEW_FILE"
    exit 1
fi

# --- Force Mode vs Preview Mode ---
if [ "$effective_force_mode" = true ]; then
    # Force mode: apply changes and exit
    if diff -q "$FILE_PATH" "$PREVIEW_FILE" >/dev/null 2>&1; then
        rm -f "$PREVIEW_FILE"
        echo "✨ No changes needed (file already matches desired state)"
        exit 0
    fi
    
    # Apply changes
    mv "$PREVIEW_FILE" "$FILE_PATH"
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        git add "$FILE_PATH" 2>/dev/null || true
    fi
    
    echo "✨ Changes applied successfully"
    exit 0
else
    # Preview mode: show diff and instructions
    echo "✨ Edits applied to a temporary preview. Review the changes below:"
    echo

    if diff -q "$FILE_PATH" "$PREVIEW_FILE" >/dev/null 2>&1; then
        echo "No changes were made to the file content."
        # Don't remove preview file, keep it around for test verification
        if [ "$DEBUG_MODE" = true ]; then
            echo "Debug mode: No changes needed, preview file removed" >&2
        fi
    else
        # Show the diff using git diff for better formatting
        if command -v git >/dev/null 2>&1; then
            # Show diff and ignore status since finding changes returns 1
            git diff --no-index --no-prefix "$FILE_PATH" "$PREVIEW_FILE" || true
        else
            # Show diff and ignore exit status since differences cause non-zero
            diff -u "$FILE_PATH" "$PREVIEW_FILE" || true
        fi

        echo
        echo "To apply these changes, run:"
        # Use original paths for display
        echo "  mv '$PREVIEW_FILE' '$FILE_PATH'"

        # Add git staging hint if in a git repository
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo " && git add '$FILE_PATH'"
        fi

        echo
        echo "To discard these changes, run:"
        echo "  rm '$PREVIEW_FILE'"
    fi
fi
